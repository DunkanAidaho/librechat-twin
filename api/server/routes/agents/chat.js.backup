
const { logger } = require('@librechat/data-schemas');
const { renderMetrics } = require('~/utils/metrics');
const ingestDeduplicator = require('~/server/services/Deduplication/ingestDeduplicator');
const { runWithResilience } = require('~/utils/async');
const express = require('express');
const { generateCheckAccess, skipAgentCheck } = require('@librechat/api');
const { PermissionTypes, Permissions, PermissionBits } = require('librechat-data-provider');
const {
  setHeaders,
  moderateText,
  // validateModel,
  validateConvoAccess,
  buildEndpointOption,
  canAccessAgentFromBody,
} = require('~/server/middleware');
const { initializeClient } = require('~/server/services/Endpoints/agents');
const AgentController = require('~/server/controllers/agents/request');
const addTitle = require('~/server/services/Endpoints/agents/title');
const { getRoleByName } = require('~/models/Role');
const { validateAgentRequest } = require('~/server/middleware/requestValidators');

const router = express.Router();

router.use(moderateText);

const checkAgentAccess = generateCheckAccess({
  permissionType: PermissionTypes.AGENTS,
  permissions: [Permissions.USE],
  skipCheck: skipAgentCheck,
  getRoleByName,
});
const checkAgentResourceAccess = canAccessAgentFromBody({
  requiredPermission: PermissionBits.VIEW,
});

router.use(checkAgentAccess);
router.use(checkAgentResourceAccess);
router.use(validateAgentRequest);
router.use(validateConvoAccess);
router.use(buildEndpointOption);
router.use(setHeaders);

const controller = async (req, res, next) => {
  await AgentController(req, res, next, initializeClient, addTitle);
};

/**
 * @route POST / (regular endpoint)
 * @desc Chat with an assistant
 * @access Public
 * @param {express.Request} req - The request object, containing the request data.
 * @param {express.Response} res - The response object, used to send back a response.
 * @returns {void}
 */
router.post('/', controller);

/**
 * @route POST /:endpoint (ephemeral agents)
 * @desc Chat with an assistant
 * @access Public
 * @param {express.Request} req - The request object, containing the request data.
 * @param {express.Response} res - The response object, used to send back a response.
 * @returns {void}
 */
router.post('/:endpoint', controller);


/**
 * /metrics: Prometheus метрики (auth METRICS_AUTH).
 * @route GET /api/agents/metrics
 * @returns {text} Prometheus.
 */
router.get('/metrics', (req, res) => {
  const auth = req.headers.authorization;
  const expected = process.env.METRICS_AUTH || 'Basic YWRtaW46cGFzcw==';
  if (!auth || auth !== expected) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  try {
    res.set('Content-Type', 'text/plain; version=0.0.4');
    res.send(renderMetrics());
  } catch (e) {
    logger.error('[metrics] Error: %s', e.message);
    res.status(500).json({ error: 'Metrics render failed' });
  }
});


/**
 * /diagnostics/ingest-dedupe: Диагностика дедуп (status, cache, keys).
 * @route GET /api/agents/diagnostics/ingest-dedupe?limit=100
 * @returns {Object} JSON.
 */
router.get('/diagnostics/ingest-dedupe', async (req, res) => {
  const start = Date.now();
  try {
    const result = await runWithResilience('diagnostics-dedup', async () => {
      await ingestDeduplicator.initialize();
      const keys = await ingestDeduplicator.getAllIngestMarks();
      const limit = parseInt(req.query.limit) || 100;
      return {
        jetstream: process.env.NATS_ENABLED === 'true',
        cacheSize: keys.length,
        hits: 0,  // No export, hardcode 0 (warn: metrics.ingest_dedupe_hits_total not available)
        misses: 0,  // No export, hardcode 0 (warn: metrics.ingest_dedupe_misses_total not available)
        keys: keys.slice(0, limit),
	warning: 'ingest_dedupe metrics not exported, hits/misses=0'
    }, { timeoutMs: 5000, retries: 1 });
    logger.info('[diagnostics] OK (dur=%dms, keys=%d)', Date.now() - start, result.cacheSize);
    res.json(result);
  } catch (e) {
    logger.error('[diagnostics] Failed (dur=%dms): %s', Date.now() - start, e.message);
    res.status(500).json({ error: `NATS error: ${e.message}` });
  } finally {
    await ingestDeduplicator.shutdown();
  }
});



module.exports = router;
