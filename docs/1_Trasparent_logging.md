Ниже предлагаю план внедрения единого многоуровневого логирования:

**1. Цели, критерии успеха и ограничения**
- **Цель:** ввести централизованный слой логирования для всех серверных модулей (клиенты LLM, контроллеры, сервисы, worker’ы), обеспечив единый формат и уровни (`error/warn/info/debug/trace` + опциональные доменные теги), с конфигурацией через `ConfigService`.
- **Deliverables:**
  1. Новый модуль логирования (например `api/utils/logger/index.js`) на базе Winston или pino с:
     - настройкой уровней и транспортых каналов (консоль + опционально файл/JSON);
     - функцией `createScopedLogger(scope, options)` для включения доменных тегов;
     - поддержкой динамических флагов (`tracePipeline`, `debugSse`, `tokenUsageReportMode`).
  2. Расширение `ConfigService` (`logging` секция) новыми параметрами: глобальный уровень, формат вывода (json/text), включение файлового транспорта, опции трассировки.
  3. Обновление существующих модулей (начать с ключевых: `server/controllers/agents/*`, `app/clients/*`, `server/services/RAG/*`, `utils/metrics`, `memoryQueue`, `branchLogger` и т.д.), чтобы они использовали новый API и единый стиль сообщений.
  4. Документация (`README`/`project_map`/`docs/logging.md`) с описанием уровней, переменных окружения и правил добавления новых логов.
- **Критерии успеха:**
  - все основные узлы создают scoped-логгер через новый модуль;
  - уровни управляются через ENV, включение trace/debug не требует правок кода;
  - лог-сообщения содержат единый формат (timestamp, scope, level, message, context JSON);
  - ветвевой логгер (`branchLogger`) переиспользует этот слой, нет дублирования конфигурации;
  - регрессионных изменений в функционале нет (тесты/линтеры проходят).
- **Ограничения:** сохраняем совместимость с существующими ENV переменными (например `ENABLE_BRANCH_LOGGING`, `BRANCH_LOG_LEVEL`, `TRACE_PIPELINE`). Логи не должны перегружать stdout при прод-настройках; опционально поддержать файл/JSON transport, но дефолт остаётся консоль.
  - Критически важно соблюдать оптимизацию из `docs/TODO.md` (п.1 «sanitizeInput fast-path»):
    - любой пользовательский ввод перед логированием проходит через текущий `sanitizeInput` fast-path;
    - запрещено возвращаться к тяжёлым `JSON.stringify`/доп. аллокациям в hot-path (sanitizeInput, обработчики сообщений);
    - `meta` в логах может содержать только лёгкие копии/обрезки строк (без повторной нормализации).

### 1.1 Операционные требования при переносе модулей логирования
- **Чистое рабочее дерево:** перед переносом/переименованием логгеров выполняем `git status --short` и удаляем устаревшие файлы (`logger.js`, резервные копии). Если файлы были вынесены в подпапки, убедиться, что корень не содержит теневых дублей.
- **Нулевая кэшированность сборки:** следующий запуск контейнера выполняем через `docker build --no-cache` (или эквивалентный шаг CI), чтобы гарантировать отсутствие «прилипших» модулей из предыдущих слоёв.
- **Локальные линтеры/трансформации:** после удаления старых файлов прогоняем статические проверки (`npm run lint`, `eslint .`) без запуска прод-приложения. Ошибки типа `Cannot find module '~/utils/logger'` должны отлавливаться на этом этапе.
- **Документация:** каждое перемещение или консолидация логгера фиксируется в `docs/project_map` и `docs/coder_checklist.md`, чтобы команда знала, какие файлы необходимо удалять при cherry-pick/pull.

**2. План работ**
1. **Анализ и проектирование API**
   - Определить требования к форматам (structured JSON vs human-readable) и стандарт полей.
   - Спроектировать функции: `getLogger(scope)`, `withDebug(flagName)` и т.д.
   - Уточнить, нужна ли асинхронная отправка (например в external collector). 
2. **Расширение ConfigService**
   - Добавить поля `logging.globalLevel`, `logging.format`, `logging.console.colorize`, `logging.file.enabled`, `logging.file.path`, `logging.features.tracePipeline`, и т.п.
   - Обновить схему Zod, обеспечить значения по умолчанию, задокументировать новые ENV-переменные.
3. **Создание нового модуля логирования**
   - Реализовать единый инстанс логгера, читающий конфиг;
   - Добавить helper для scoped логger’ов (`logger.child({ scope: 'RAG.Condense' })`);
   - Инкапсулировать ветвевое логирование: либо новый transport, либо адаптер `branchLogger`.
4. **Рефакторинг существующих модулей** (итеративно, начиная с критичных):
   - `server/controllers/agents/client.js` и `request.js` – заменить `console/debug/warn` (или `logger` из сторонних пакетов) на scoped logger;
   - Клиенты `app/clients/*` – добавить логирование запросов/ответов с одинаковыми полями (`endpoint`, `model`, `latency`, `retryAttempt`);
   - RAG/memory сервисы и очереди – логировать ключевые этапы, ошибки, метрики через новый API;
   - Удалить устаревшие `debug` зависимости, мигрировать `branchLogger`.
5. **Единые уровни и контекст**
   - Ввести соглашения по тегам/поля (например, `context: { conversationId, userId, requestId }`).
   - Добавить middleware (в `routes/agents/chat.js`) для присвоения `requestId` и передачи в scoped логгеры.
   - Для user-generated полей использовать helper `safeMeta()`/`sanitizePlainObject` с fast-path sanitize, короткой обрезкой строк и поддержкой структур (без повторных JSON.stringify).
6. **Документация и примеры**
   - Создать `docs/logging.md` или обновить `project_map.md` разделом «Logging» с инструкциями по включению уровней, примером ENV и best practices.
7. **Проверка**
   - Прогнать существующие тесты/линтер.
   - Локально проверить разные уровни (info, debug, trace) через ENV.
   - Убедиться, что при отключённом `tracePipeline` шум минимален, а при включении появляется детальная трассировка.
   - Чек-лист: «Перед логированием user-generated полей используется fast-path sanitizeInput или `sanitizePlainObject`; `JSON.stringify` в hot-path отсутствует».


